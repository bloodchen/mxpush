import { TypedEmitter, EventMap } from "./lib/TypedEmitter";
import { Session, DefaultSessionState } from "./Session";
interface BroadcastOptions<SessionState extends Record<string, unknown> = DefaultSessionState> {
    /**
     * Filter sessions that should receive the event.
     *
     * Called with each session and should return `true` to allow the event to be sent and otherwise return `false` to prevent the session from receiving the event.
     */
    filter?: (session: Session<SessionState>) => boolean;
}
interface ChannelEvents<SessionState extends Record<string, unknown> = DefaultSessionState> extends EventMap {
    "session-registered": (session: Session<SessionState>) => void;
    "session-deregistered": (session: Session<SessionState>) => void;
    "session-disconnected": (session: Session<SessionState>) => void;
    broadcast: (data: unknown, eventName: string, eventId: string) => void;
}
interface DefaultChannelState {
    [key: string]: unknown;
}
/**
 * A `Channel` is used to broadcast events to many sessions at once.
 *
 * It extends from the {@link https://nodejs.org/api/events.html#events_class_eventemitter | EventEmitter} class.
 *
 * You may use the second generic argument `SessionState` to enforce that only sessions with the same state type may be registered with this channel.
 */
declare class Channel<State extends Record<string, unknown> = DefaultChannelState, SessionState extends Record<string, unknown> = DefaultSessionState> extends TypedEmitter<ChannelEvents<SessionState>> {
    /**
     * Custom state for this channel.
     *
     * Use this object to safely store information related to the channel.
     */
    state: State;
    private sessions;
    constructor();
    /**
     * List of the currently active sessions subscribed to this channel.
     */
    get activeSessions(): ReadonlyArray<Session<SessionState>>;
    /**
     * Number of sessions subscribed to this channel.
     */
    get sessionCount(): number;
    /**
     * Register a session so that it can start receiving events from this channel.
     *
     * If the session was already registered to begin with this method does nothing.
     *
     * @param session - Session to register.
     */
    register(session: Session<SessionState>): this;
    /**
     * Deregister a session so that it no longer receives events from this channel.
     *
     * If the session was not registered to begin with this method does nothing.
     *
     * @param session - Session to deregister.
     */
    deregister(session: Session<SessionState>): this;
    /**
     * Broadcast an event to every active session registered with this channel.
     *
     * Under the hood this calls the `push` method on every active session.
     *
     * If no event name is given, the event name is set to `"message"`.
     *
     * Note that the broadcasted event will have the same ID across all receiving sessions instead of generating a unique ID for each.
     *
     * @param data - Data to write.
     * @param eventName - Event name to write.
     */
    broadcast: (data: unknown, eventName?: string, options?: BroadcastOptions<SessionState>) => this;
}
export type { BroadcastOptions, ChannelEvents, DefaultChannelState };
export { Channel };
